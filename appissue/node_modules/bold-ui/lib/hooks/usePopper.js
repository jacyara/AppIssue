"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var popper_js_1 = __importDefault(require("popper.js"));
var react_1 = require("react");
var defaultOpts = {
    placement: 'bottom',
    eventsEnabled: true,
    positionFixed: false,
};
var initialStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    opacity: 0,
    pointerEvents: 'none',
};
var initialArrowStyle = {};
var noop = function () { return null; };
function usePopper(inputOpts, inputs) {
    if (inputs === void 0) { inputs = []; }
    var opts = __assign(__assign({}, defaultOpts), inputOpts);
    var anchorRef = opts.anchorRef, popperRef = opts.popperRef, arrowRef = opts.arrowRef;
    var _a = react_1.useState(function () { return ({
        data: undefined,
        placement: undefined,
    }); }), state = _a[0], setState = _a[1];
    var popperInstance = react_1.useRef();
    var callbackFn = react_1.useCallback(function (data) {
        var placement = data.placement;
        setState({ data: data, placement: placement });
        return data;
    }, []);
    react_1.useEffect(function () {
        // A placement difference in state means popper determined a new placement
        // apart from the opts value. By the time the popper element is rendered with
        // the new position Popper has already measured it, if the place change triggers
        // a size change it will result in a misaligned popper. So we schedule an update to be sure.
        if (popperInstance.current) {
            popperInstance.current.scheduleUpdate();
        }
    }, [state.placement]);
    react_1.useEffect(function () {
        if (anchorRef.current && popperRef.current) {
            popperInstance.current = new popper_js_1.default(anchorRef.current, popperRef.current, {
                placement: opts.placement,
                eventsEnabled: opts.eventsEnabled,
                positionFixed: opts.positionFixed,
                modifiers: __assign(__assign({}, opts.modifiers), { arrow: __assign(__assign({}, (opts.modifiers && opts.modifiers.arrow)), { enabled: !!(arrowRef && arrowRef.current), element: arrowRef && arrowRef.current }), applyStyle: { enabled: false }, updateStateModifier: {
                        enabled: true,
                        order: 900,
                        fn: callbackFn,
                    } }),
            });
        }
        return function () {
            if (popperInstance.current) {
                popperInstance.current.destroy();
                popperInstance.current = null;
            }
        };
    }, inputs);
    var style = !popperRef.current || !state.data
        ? initialStyle
        : __assign({ position: state.data.offsets.popper.position }, state.data.styles);
    var arrowStyle = !arrowRef || arrowRef.current || !state.data ? initialArrowStyle : state.data.arrowStyles;
    return {
        style: style,
        placement: state.placement,
        outOfBoundaries: state.data && state.data.hide,
        scheduleUpdate: popperInstance.current ? popperInstance.current.scheduleUpdate : noop,
        arrowStyle: arrowStyle,
    };
}
exports.default = usePopper;
//# sourceMappingURL=usePopper.js.map